#include <assert.h>
#include <stdbool.h>
#include "code_line_cl.h"
#include "dbg.h"
#include "dimensions.h"
#include "aux.h"

#define INSTRUCTION_STRING_LENGTH 20

static operand_t *copy_operand(operand_t *op);
bool check_valid_operand(int id);

char *add_text = "add";
char *mov_text = "mov";
char *label_text = "LABEL";
char *jmp_text = "jmp";
char *rax_text = "rax";
char *rbx_text = "rbx";
char *rcx_text = "rcx";
char *rdx_text = "rdx";
char *rdi_text = "rdi";
char *ib_text = "[ib]";
char *ob_text = "[ob]";

/* Function: cl_check_op_is_register
 * -----------------------------------------------------------------------------
 * Verifies using the id of the operand if corresponds to a register
 *
 * Arguments:
 * 	op_id: Te id of the operand that will be verified
 *	
 * Return:
 *	true if the id of the operand corresponds to a register
 *
 */
bool cl_check_op_is_register(int op_id)
{
	assert(((op_id > REGISTERS_MIN && op_id < REGISTERS_MAX) || 
			(op_id > MEMORY_MIN && op_id < MEMORY_MAX) || 
			(op_id > BUFFERS_MIN && op_id < BUFFERS_MAX) || 
			(op_id > RGBOX_MIN && op_id < RGBOX_MAX)) &&
			"Invalid operand id");
	
	bool is_register = false;	
	
	if (op_id > REGISTERS_MIN && op_id < REGISTERS_MAX){
		is_register = true;		
	}
	return is_register;
}

/* Function: cl_check_both_operands_are_registers
 * -----------------------------------------------------------------------------
 * Determines if the operands of a given line, both are registers.
 *
 * Arguments:
 * 	line: the line object that will be analized
 *	
 * Return:
 *	true if both operands are registers
 *
 */
bool cl_operands_are_registers(code_line_t *line)
{
	bool op1 = false;
	bool op2 = false;

	if (line->op1->id > REGISTERS_MIN && line->op1->id < REGISTERS_MAX){
		op1 = true;
	}
	if (line->op2->id > REGISTERS_MIN && line->op2->id < REGISTERS_MAX){
		op2 = true;
	} 
	return op1 & op2;
}

/* Function: cl_new_code_line
 * -----------------------------------------------------------------------------
 * This function generates a new code_line object of a pointer it creates a 
 * different pointers that can be used on a list. It is used in the instruction
 * window
 *
 * Arguments:
 * 	instruction: the instruction of the new line that will be created
 *	
 * Return:
 *	The new code_line_object
 *
 */
code_line_t *cl_new_code_line(instruction_t *ins)
{
	texture_t *t = cl_create_instruction_texture(ins->id);	
	button_t *b = create_button(ins->b->x, ins->b->y, ins->b->w, ins->b->h, 
							  	ins->b->active, ins->b->rectangle, t);

	instruction_t *i = cl_create_instruction(ins->id, b);
	code_line_t *new = cl_create_code_line(i);

	return new;
}

/* Function: cl_create_instruction_texture
 * -----------------------------------------------------------------------------
 * Arguments:
 * 	id: The id of the texture that must be returned
 *	
 * Return:
 *	void
 *
 */
texture_t *cl_create_instruction_texture(int id)
{
	assert(id > INSTRUCTION_MIN && id < INSTRUCTION_MAX &&  "Incorrect id");
	texture_t *texture = NULL;
	
	switch(id){
		case MOV:
			texture = load_texture_from_rendered_text(mov_text, COLOR_WHITE);
			break;
		case ADD:
			texture = load_texture_from_rendered_text(add_text, COLOR_WHITE);
			break;
		case LABEL:
			texture = load_texture_from_rendered_text(label_text, COLOR_WHITE);
			break;
		case JMP:
			texture = load_texture_from_rendered_text(jmp_text, COLOR_WHITE);
			break;
		default:
			printf("Error: the id of the register is invalid");
				
	}
	return texture;
}

/* Function: cl_create_operand_texture
 * -----------------------------------------------------------------------------
 * Arguments:
 * 	id: The id of the texture that must be returned
 *	
 * Return:
 *	void
 *
 */
texture_t *cl_create_operand_texture(int id)
{
	assert(((id > REGISTERS_MIN && id < REGISTERS_MAX) ||
			(id > BUFFERS_MIN && id < BUFFERS_MAX)) &&  "Incorrect id");
	texture_t *texture = NULL;
	
	switch(id){
		case RAX:
			texture = load_texture_from_rendered_text(rax_text, COLOR_WHITE);
			break;
		case RBX:
			texture = load_texture_from_rendered_text(rbx_text, COLOR_WHITE);
			break;
		case RCX:
			texture = load_texture_from_rendered_text(rcx_text, COLOR_WHITE);
			break;
		case RDX:
			texture = load_texture_from_rendered_text(rdx_text, COLOR_WHITE);
			break;
		case RDI:
			texture = load_texture_from_rendered_text(rdi_text, COLOR_WHITE);
			break;
		case IB:
			texture = load_texture_from_rendered_text(ib_text, COLOR_WHITE);
			break;
		case OB:
			texture = load_texture_from_rendered_text(ob_text, COLOR_WHITE);
			break;
		default:
			printf("Error: the id of the register is invalid");
				
	}
	return texture;
}

/* Function: cl_text_to_operand_id
 *------------------------------------------------------------------------------
 * Arguments:
 * 	text: the text of the instruction that will be converted
 *	
 * Return:
 *	instruction_id: The numerical identifier of the instruction.
 */
int cl_text_to_operand_id(char *text)
{
	int operand_id = INVALID_OPERAND;
	if (strstr(text, rax_text) != NULL){
		operand_id = RAX;
	} else if (strstr(text, rbx_text)!= NULL){
		operand_id = RBX;
	} else if (strstr(text, rcx_text)!= NULL){
		operand_id = RCX;
	} else if (strstr(text, rdx_text)!= NULL){
		operand_id = RDX;
	} else if (strstr(text, rdi_text)!= NULL){
		operand_id = RDI;
	} else if (strstr(text, ib_text)!= NULL){
		operand_id = IB;
	} else if (strstr(text, ob_text)!= NULL){
		operand_id = OB;
	} 
	assert(operand_id != INVALID_OPERAND && "Operand id is invalid");
	return operand_id;
}

/* Function: cl_text_to_instruction_id
 *------------------------------------------------------------------------------
 * Arguments:
 * 	text: the text of the instruction that will be converted
 *	
 * Return:
 *	instruction_id: The numerical identifier of the instruction.
 */
int cl_text_to_instruction_id(char *text)
{
	int instruction_id = INVALID_OPERAND;

	if (strstr(text, mov_text) != NULL){
		instruction_id = MOV;
	} else if (strstr(text, add_text)!= NULL){
		instruction_id = ADD;
	} else if (strstr(text, label_text)!= NULL){
		instruction_id = LABEL;
	} else if (strstr(text, jmp_text)!= NULL){
		instruction_id = JMP;
	}

	assert(instruction_id != INVALID_OPERAND && "Instruction id is invalid");
	return instruction_id;
}

/* Function: print_code_line
 *------------------------------------------------------------------------------
 * Arguments:
 * 	line: the line that will be printed
 *	
 * Return:
 *	void.
 */
void print_code_line(code_line_t *line)
{
	char *ins_text = cl_get_instruction_text(line->ins->id);
	char *op1 = get_operand_text(line->op1->id);
	char *op2 = get_operand_text(line->op2->id);

	printf("%s %s, %s\n", ins_text, op1, op2);

}

/* Function: get_instruction_operand_quantity
 *------------------------------------------------------------------------------
 * Arguments:
 * 	instruction: the instruction that will be checked
 *	
 * Return:
 *	int with the number of operands of the instruction
 */
int cl_get_instruction_operand_quantity(int instruction_id)
{
	assert(instruction_id > INSTRUCTION_MIN && 
	       instruction_id < INSTRUCTION_MAX && "The instruction id is invalid");

	int number_of_operands = ZERO_OPERANDS;
	switch (instruction_id){
		case MOV:
			number_of_operands = TWO_OPERANDS;
			break;
		case ADD:
			number_of_operands = TWO_OPERANDS;
			break;
		case LABEL:
			number_of_operands = ONE_OPERAND;
			break;
		case JMP:
			number_of_operands = ONE_OPERAND;
			break;
		default:
			number_of_operands = ZERO_OPERANDS;
			break;


	}
	return number_of_operands;
}

/* Function: cl_get_instruction_text
 *------------------------------------------------------------------------------
 * Arguments:
 * 	instruction_id: the id of the instruction
 *	
 * Return:
 *	char pointer with the name of the instruction
 */
char *cl_get_instruction_text(int instruction_id)
{
	assert(instruction_id > INSTRUCTION_MIN && 
	       instruction_id < INSTRUCTION_MAX && "The instruction id is invalid");

	char *text;

	switch (instruction_id){
		case MOV:
			text = mov_text;
			break;
		case ADD:
			text = add_text;
			break;
		case LABEL:
			text = label_text;
			break;
		case JMP:
			text = jmp_text;
			break;
	}
error:
	return text;
}

/* Function: get_operand_text
 *------------------------------------------------------------------------------
 * Arguments:
 * 	instruction_id: the id of the operand
 *	
 * Return:
 *	char pointer with the name of the instruction
 */
char *get_operand_text(int operand_id)
{
	assert(operand_id > REGISTERS_MIN && operand_id < BUFFERS_MAX && 
		   "The operand id is invalid");

	char *text;

	switch (operand_id){
		case RAX:
			text = rax_text;
			break;
		case RBX:
			text = rbx_text;
			break;
		case RCX:
			text = rcx_text;
			break;
		case RDX:
			text = rdx_text;
			break;
		case RDI:
			text = rdi_text;
			break;
		case IB:
			text = ib_text;
			break;
		case OB:
			text = ob_text;
			break;
	}
error:
	return text;
}

/* Function: cl_create_code_line_text
 * -----------------------------------------------------------------------------
 * This function generates the string of a code line, the string will be single
 * and it will include the whole instruction in a single line
 *
 * Arguments:
 * 	instruction_id: The number id of the instruction
 * 	op1_id: The number id of the operand 1
 * 	op2_id: The number id of the operand 2
 *
 * Return:
 *	Pointer to the created string
 */
char *cl_create_code_line_text(int instruction_id, int op1_id, int op2_id)
{
	assert(instruction_id > INSTRUCTION_MIN && instruction_id < INSTRUCTION_MAX
		  && "The instruction id is invalid");
	if (instruction_id == JMP){
		assert(op1_id >=0 && "The operand id for a jump is negative");
	} else {
		assert(op1_id >= NO_OPERAND && op1_id < BUFFERS_MAX && "Invalid OP1");
		assert(op2_id >= NO_OPERAND && op2_id < BUFFERS_MAX && "Invalid OP2");
	}

	char *line_text = malloc(sizeof(char)*INSTRUCTION_STRING_LENGTH);
	char *instruction = cl_get_instruction_text(instruction_id);
	strcpy(line_text, instruction);
	
	if (instruction_id == LABEL || instruction_id == JMP) {
		char *op1 = NULL;
		op1 = ax_number_to_string_two_digits(op1_id);
		strcat(line_text, char_space);
		strcat(line_text, op1);
	} else if (op1_id != NO_OPERAND){
		char *op1 = NULL;
		op1 = get_operand_text(op1_id);
		strcat(line_text, char_space);
		strcat(line_text, op1);
	}
	if (op2_id != NO_OPERAND){
		char *op2 = get_operand_text(op2_id);
		strcat(line_text, char_comma);
		strcat(line_text, char_space);
		strcat(line_text, op2);
	}
	strcat(line_text, char_newline);
	return line_text;
}


/* Function: cl_create_instruction
 * -----------------------------------------------------------------------------
 * This function creates a instruction object.
 *
 * Arguments:
 * 	id: the id of the instruction that will be created.
 * 	b: the button object of the instruction.
 *
 * Return:
 *	Pointer to the created code node
 */
instruction_t *cl_create_instruction(int id, button_t *b)
{
	assert(NULL != b && "The button pointer is NULL");
	assert(id > INSTRUCTION_MIN && id < INSTRUCTION_MAX && 
		   "Invalid instruction id");
	
	instruction_t *ins = malloc(sizeof(instruction_t));	

	ins->b = b;
	ins->id = id;
	return ins;
}


/* Function: cl_create_code_line
 * -----------------------------------------------------------------------------
 * This function creates a code line with a given instruction object, the other
 * elements of the instruction are filled with defaults.
 *
 * Arguments:
 * 	ins: the button object of the instruction to be added to the new code line.
 *
 * Return:
 *	Pointer to the created code line
 */
code_line_t *cl_create_code_line(instruction_t *ins)
{
	assert(NULL != ins && "The instruction pointer is NULL");
	
	code_line_t *new_line = malloc(sizeof(code_line_t));	
	check_mem(new_line);

	new_line->ins = ins;
	new_line->op1 = NULL;
	new_line->op2 = NULL;

	if (cl_get_instruction_operand_quantity(ins->id) == ZERO_OPERANDS){
		new_line->state = COMPLETE;
	} else if (cl_get_instruction_operand_quantity(ins->id) == ONE_OPERAND){
		new_line->state = MISSING_OP1;
	} else if (cl_get_instruction_operand_quantity(ins->id) == TWO_OPERANDS){
		new_line->state = MISSING_BOTH;
	} else{
		assert("Invalid instruction operand quantity");
	}

error:
	return new_line;
}

/* Function: cl_destroy_code_line
 * -----------------------------------------------------------------------------
 * This function frees and destroys a code line object 
 *
 * Arguments:
 * 	code_line: the the code line object to be destroyed
 *	
 * Return:
 *	Void
 *
 */
void cl_destroy_code_line(code_line_t *line)
{
	bt_destroy_button(line->ins->b);
	free(line->ins);

	if (line->op1 != NULL){
		bt_destroy_button(line->op1->b);
		free(line->op1);
	}
	if (line->op2 != NULL){
		bt_destroy_button(line->op2->b);
		free(line->op2);
	}
	free(line);
}



/* Function: copy_operand
 * -----------------------------------------------------------------------------
 * This function creates a new operand object by copying the button object and
 * the id. The pointer of the value is copied as well in order to maintain
 * consistency.
 *
 * Arguments:
 *	op: the operand that will be copied.
 *	
 * Return:
 *	object to the new operand that is a copy.
 *
 */
static operand_t *copy_operand(operand_t *op)
{
	assert(NULL != op && "The operand pointer cannot be NULL");
	button_t *b = bt_copy_button(op->b);
	check_mem(b);

	operand_t *new_op = malloc(sizeof(operand_t));
	check_mem(new_op);
	new_op->b = b;
	new_op->id = op->id;
	
error:
	return new_op;
}

/* Function: check_valid_operand
 * -----------------------------------------------------------------------------
 * This function verifies is an operand id is valid
 *
 * Arguments:
 *  id: The operand id that will be verified.
 *	
 * Return:
 *	void.
 *
 */
bool check_valid_operand(int id)
{
	bool valid = false;

	if (id > REGISTERS_MIN && id < REGISTERS_MAX ||
		id > MEMORY_MIN && id < MEMORY_MAX ||
		id > BUFFERS_MIN && id < BUFFERS_MAX){
		valid = true;
	}
	return valid;
}


/* Function: check_operand_compatibility
 * -----------------------------------------------------------------------------
 * This function verifies if when changing or assigning an operand, it e
 *
 * Arguments:
 *	operand: the operand that will be assigned.
 * 	line: the line where the operand will be assigned.
 *	
 * Return:
 *	void.
 *
 */
bool check_operand_compatilibity(operand_t *op, code_line_t *line)
{
	assert(op != NULL && "The operand cannot be NULL");
	assert(line != NULL && "The line cannot be NULL");
	assert(check_valid_operand(op->id) == true && 
		   "The operand value is not valid");

	if (cl_check_op_is_register(op->id) == true){
		return true;
	}
	bool compatible = false;

	switch(line->state){
		case MISSING_BOTH:
			if (op->id != IB){
				compatible = true;
			}
			break;
		case MISSING_OP1:
			if (cl_check_op_is_register(line->op2->id) == true && op->id != IB){
				compatible = true;
			}
			break;
		case MISSING_OP2:
			if (cl_check_op_is_register(line->op1->id) == true && op->id != OB){
				compatible = true;
			}			
			break;
		case CHANGING_OP1:
			if (cl_check_op_is_register(line->op2->id) == true && op->id != IB){
				compatible = true;
			}
			break;		
		case CHANGING_OP2:
			if (cl_check_op_is_register(line->op1->id) == true && op->id != OB){
				compatible = true;
			}			
			break;		
		case COMPLETE:
			printf("Error, there should not be an operand assigment to a "
					"complete instruction. \n");
			break;
		default:
			printf("Error, the state of the code line is invalid\n");
			break;
	}
	return compatible;
}

/* Function: cl_assign_operand_to_line
 * -----------------------------------------------------------------------------
 * This function assigns an operand to a line that has a state where the 
 * operand is missing, generates error if called to a line that is not in a
 * state of a missing operand.
 *
 * Arguments:
 *	operand: the operand that will be assigned.
 * 	line: the line where the operand will be assigned.
 *	
 * Return:
 *	void.
 *
 */
void cl_assign_operand_to_line(operand_t *op, code_line_t *line)
{
	assert(NULL != op && "The operand cannot be NULL");
	assert(NULL != line && "The line cannot be NULL");

	int operand_quantity = cl_get_instruction_operand_quantity(line->ins->id);
	switch(line->state){
		case MISSING_BOTH:
			line->op1 = op;
			line->op1->b->x = line->ins->b->x + OP1_X_OFFSET;
			line->op1->b->y = line->ins->b->y;
			line->state = MISSING_OP2;
			break;
		case MISSING_OP1:
			line->op1 = op;
			line->op1->b->x = line->ins->b->x + OP1_X_OFFSET;
			line->op1->b->y = line->ins->b->y;
			if (operand_quantity == ONE_OPERAND){
				line->state = COMPLETE;
			} else {
				line->state = MISSING_OP2;
			}
			break;
		case MISSING_OP2:
			line->op2 = op;
			line->op2->b->x = line->ins->b->x + OP2_X_OFFSET;
			line->op2->b->y = line->ins->b->y;
			line->state = COMPLETE;
			break;
		case CHANGING_OP1:
			cl_destroy_operand(line->op1);	
			line->op1 = op;
			line->op1->b->x = line->ins->b->x + OP1_X_OFFSET;
			line->op1->b->y = line->ins->b->y;
			line->state = COMPLETE;
			break;
		case CHANGING_OP2:
			cl_destroy_operand(line->op2);	
			line->op2 = op;
			line->op2->b->x = line->ins->b->x + OP2_X_OFFSET;
			line->op2->b->y = line->ins->b->y;
			line->state = COMPLETE;
			break;
		case COMPLETE:
			printf("cl_assign_operand_to line Error, there should not be an" 
					"operand assigment to a complete instruction. \n");
			break;
		default:
			printf("Error, the state of the code line is invalid\n");
			break;
	}
}

/* Function: cl_create_operand
 * -----------------------------------------------------------------------------
 * This function creates a operand object.
 *
 * Arguments:
 * 	id: the id of the instruction that will be created.
 * 	b: the button object of the instruction.
 *
 * Return:
 *	Pointer to the created code node
 */
operand_t *cl_create_operand(int id, button_t *b)
{
	assert(NULL != b && "The button pointer is NULL");
	assert((id > REGISTERS_MIN && id < REGISTERS_MAX ||
			id > MEMORY_MIN && id < MEMORY_MAX ||
			id > BUFFERS_MIN && id < BUFFERS_MAX) && 
	        "Invalid operand id");
	
	operand_t *op = malloc(sizeof(operand_t));	
	check_mem(op);

	op->b = b;
	op->id = id;
	//op->value = malloc(sizeof(int));
	//check_mem(op->value);

error:
	return op;
}

/* Function: cl_destroy_operand
 * -----------------------------------------------------------------------------
 * This function destroys an operand object.
 *
 * Arguments:
 * 	op: the operand that will be destroyed
 *
 * Return:
 *	void.
 */
void cl_destroy_operand(operand_t *op)
{
	assert(NULL != op && "The operand pointer is NULL");
	
	bt_destroy_button(op->b);
	free(op);

	return;
}
